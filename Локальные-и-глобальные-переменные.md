# Локальные и глобальные переменные

> Тут вижу, тут не вижу

Если кто-то изучал раньше Паскаль, то, возможно, поймет меня. Лично меня страшно бесило, что все переменные в этом языке нужно было объявлять в начале процедуры.

```pascal
Procedure Example();
Var
  a, b, c : real;
begin
  a := 5.2;
  b := 2.1;
  c := a-b;
end ;
```

Каждый раз, когда ты понимаешь, что нужна еще одна переменная, нужно скроллить вверх, находить объявление переменных, добавлять туда переменную, возвращаться обратно и продолжать работу. И это притом, что процедура не всегда влезает в один экран! В общем, кошмар.

В С++ такого нет. Переменная может быть объявлена в любом месте программы. Причем считается правильным объявлять переменную как можно ближе к месту, где она будет использована.

Однако, согласитесь может возникнуть премерзкая ситуация:

```c++
bool flag = true;
int a;
if(flag)
{	
	int b;
	cin >> b; // Просим пользователя ввести с клавиатуры число b
	a = b*2;
}
else
{
	int b = 4;
	a = b/2;
}
```

Понятно, что этот алгоритм можно легко переписать правильно, и тогда двойного объявления переменной b можно избежать, но мне важно проиллюстрировать то, о чем сейчас пойдет речь.

У нас сейчас в одном алгоритме получилось, что объявлено 2 переменных с одним и тем же именем - b. Вроде бы, должна быть ошибка, потому что возникает неоднозначность, какая переменная b, где используется.

Логически мы понимаем, что в двух разных блоках кода - две разные переменные b. И это правильно. Чтобы избежать таких конфликтов в С++ тоже есть понятия, которые позволяют избежать таких неоднозначностей: локальная переменные и глобальные переменные.
```c++
#pragma once

#include <iostream>
using namespace std;

namespace LocalGlobalVariables
{
    int count; // "Глобальная"

    void func1()
    {
        int x = 10;

        count++; // Внутри ф-ции мы не объявляли переменную count
                 // Но она все равно доступна, и мы увеличиваем ее значение
    }

    void func2()
    {
        int x = -199;

        count++; // Та же ситуация
    }

    void main()
    {
        count = 0; 
        setlocale(LC_ALL, "rus");

        int t; // А вот это уже локальная переменная
        cin >> t;

        if (t == 1)
        {
            char buf[80];

            cout << "Введите имя:";
            cin >> buf;
        }
```
// В начале программы обнуляем значение переменной. То же самое - внутри main не было объявления переменной, но доступ к ней мы имеем
```c++
  void main()
    {
        count = 0;
        setlocale(LC_ALL, "rus");
	int t; 
        cin >> t;
```

**Если кратко:**
1. Глобальные переменные хранятся на протяжение выполнения всей программы. Т.е. занимают под себя место. 
2. Имя глобальной переменной занято. Создание локальной переменной в таким же именем затруднит чтение кода.
3. Алгоритм программы становится менее прозрачным, потому что вам нужно знать про все глобальные переменные, какие есть в коде.

 Если очень кратко:
 ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ - ПЛОХО! НЕ ИСПОЛЬЗУЙТЕ ИХ.

Если хотите более развернутого ответа, то можете погуглить.
Например, http://www.gunsmoker.ru/2011/04/blog-post.html

## Глобальные переменные

Глобальные переменные доступны из любого места в модуле программы. (Т.к. с понятием модуля в языке С++ кто-то может быть пока что не знаком, считайте, что это тот файл, в котором вы пишете код, например, main.cpp)

```c++
int tmp = 5; // tmp - глобальная переменная

void Func()
{
	tmp = 0;
}

int main()
{
	tmp = tmp+100;
	Func();
	cout << tmp; // Выведется 0
}
```
Не смотря на то, что в этой функции не было объявлено переменной tmp, но есть глобальная переменная tmp, которая и задействовалась в блоке кода ниже
```c++	
	 void Func()
    {
        tmp = 0;
    }
```
Глобальные переменные в С++ объявляются вне всех функций. Например, в самом начале программы. И работать с такой переменной можно в любом месте программы, не взирая на границы блоков кода.

> Блок кода - код расположенный между символами '{' и '}'

Тогда возникает разумный вопрос: если глобальные переменные такие удобные, почему нельзя везде и всюду использовать именно их?

Дело в том, что в памяти программы глобальные переменные занимают свое особое пространство. И не всегда вы можете быть уверены, что это пространство безгранично. Но даже не это страшно в **бездумном** использовании глобальных переменных.

Самое плохое - это снижение читаемости и понятности кода. Когда вы используете глобальную переменную в программах сложнее "Hello, World!" вам становится сложно сказать, где и в какой момент меняется состояние этой переменной. Вы не контролируете уровни доступа до нее. Вы можете забыть, где меняется эта переменная, а потом долга искать, почему данные в памяти имеют такой странный вид. Все это сделало использование глобальных переменных нежелательным.

Глобальные переменные такой же инструмент языка программирования, как и многие другие. Нужно уметь применять это с умом! Но всегда, когда возможно обойтись без использования шлобальных переменных, не используйте их.

**Глобальные переменные плохи по двум причинам:**

1. Они хранятся в памяти на протяжение всей программы и если глобальные переменные занимаются большой объем памяти (например, статические массивы или большие объекты), это увеличивает занимаемый программой объем оперативной памяти.

2. Снижение читабельности кода программы


По правилам хорошего тона нужно избегать использовать глобальные переменные, кроме случаев, где по архитектуре программы без этого не обойтись

## Локальные переменные

В отличии от глобальных переменных локальные существуют только в рамках того блока кода, в котором они были объявлены.

```c++
#pragma once

#include <iostream>
using namespace std;

namespace LocalVariables

void Func()
{ // <-- Начало блока кода фун-ции Func
	int c = 3;

	cout << a; // Ошибка: Идентификатор 'а' не найден
	cout << b; // Ошибка: Идентификатор 'b' не найден
	cout << c; // Ошибки не будет
} // <-- Конец блока кода фун-ции Func

int main()
{ // <-- Начало блока кода фун-ции main
	int a = 1;
	for(int i = 0; i < 10; i++)
	{ // <-- Начало блока кода цикла for
		int b = 2;
		b = b+1;

		cout << a; // Ошибки не будет
		cout << b; // Ошибки не будет
		cout << c; // Ошибка: Идентификатор 'с' не найден
		cout << i; // Ошибки не будет
	} // <-- Конец блока кода цикла for

	cout << a; // Ошибки не будет
	cout << b; // Ошибка: Идентификатор 'b' не найден
	cout << c; // Ошибка: Идентификатор 'с' не найден
	cout << i; // Ошибка: Идентификатор 'i' не найден
} // <-- Конец блока кода фун-ции main
```

**Переменная c** объявлена в фун-ции Func, поэтому существует только в рамках этой функции. Внутри функции main ее не существует, поэтому при попытке любого к ней обращения будет выдаваться ошибка.

**Переменная а** объявлена в фун-ции main и существует как в самой функции main, так и во всех дочерних блоках кода любой вложенности. Поэтому переменная а видна в любом месте функции main, в том числе внутри цикла for.

**Переменные b и i (!)** объявлены внутри цикла for. И да, переменная i является локальной переменной цикла for! Обе этих пермеенные существуют только в рамках цикла и после его завершения уже не существуют.

Разница между переменными i и b заключается в том, что переменная i создается один раз в начале цикла и существует на протяжение всех итераций этого цикла. В то время, как переменная b создается каждый раз на каждой итерации.

Поэтому на протяжение цикла, переменная i будет выводиться на экран как 0, 1, 2, 3, ..., 9, а переменная b все время будет выводиться на экран равное 2.

**Где хранятся локальные переменные**

Еще важно помнить, что локальные переменные создаются в стеке программы. И стек ограничен в своем размере.

Архитектурно такое решение оправдано тем, что в стек легко добавлять переменные при их создании с помощью команды push и достаточно помнить, сколько переменных было создано в каждом блоке кода. Тогда доатсточно сделать нужно количество команд pop по завершении блока кода, и стек всегда будет чистым и опрятным, без мусора.

К тому же стек хранит все данные подряд в отличие от "кучи" - динамической памяти программы (о ней будет рассказываться в дальнейшем), а это позволяет исключить дефрагментацию памяти, а соотвественно более высокое быстродейтсвие при работе с этой памятью.
